import json
import time
from typing import Dict, Any, Optional
from intent_classifier import IntentClassifier
from entity_extractor import EntityExtractor
from credit_calculator import CreditCalculator
from simple_intent_classifier import SimpleIntentClassifier

class ChatbotBancaire:
    def __init__(self):
        """
        Initialise le chatbot bancaire avec tous ses composants
        """
        print("üè¶ Initialisation du Chatbot Bancaire...")
        
        # Initialisation des composants
        self.intent_classifier = IntentClassifier()
        self.simple_classifier = SimpleIntentClassifier()  # Classificateur de secours
        self.entity_extractor = EntityExtractor()
        self.credit_calculator = CreditCalculator(10000,20,3.5)
        self.use_simple_classifier = False  # Flag pour basculer vers le classificateur simple
        
        # Contexte de conversation
        self.conversation_context = {}
        
        # R√©ponses types pour chaque intent
        self.responses = {
            'simulation_credit': {
                'default': "Je vais vous aider √† simuler votre cr√©dit. Pour cela, j'ai besoin de quelques informations : quel montant souhaitez-vous emprunter et sur quelle dur√©e ?",
                'with_params': "Parfait ! Je vais faire votre simulation de cr√©dit."
            },
            'demande_credit': {
                'default': "Parfait ! Je vais vous accompagner dans votre demande de cr√©dit. Voici les √©tapes √† suivre :"
            },
            'information_produit': {
                'default': "Je vais vous expliquer nos produits de cr√©dit. Que souhaitez-vous savoir ?"
            },
            'calcul_financier': {
                'default': "Je vais vous aider avec vos calculs financiers. Que voulez-vous calculer ?"
            },
            'support_client': {
                'default': "Je suis l√† pour vous aider ! Comment puis-je vous assister ?"
            },
            'modification_simulation': {
                'default': "Je vais modifier votre simulation avec les nouveaux param√®tres."
            }
        }
        
        # Informations sur les produits
        self.product_info = {
            'personnel': {
                'name': 'Cr√©dit Personnel',
                'description': 'Un cr√©dit flexible pour tous vos projets personnels',
                'features': ['Montant : 1 000‚Ç¨ √† 75 000‚Ç¨', 'Dur√©e : 12 √† 84 mois', 'Taux : 4.5% √† 7.2%'],
                'advantages': ['Usage libre', 'D√©lai de r√©ponse rapide', 'Assurance optionnelle']
            },
            'immobilier': {
                'name': 'Cr√©dit Immobilier',
                'description': 'Le financement id√©al pour votre projet immobilier',
                'features': ['Montant : 50 000‚Ç¨ √† 1 500 000‚Ç¨', 'Dur√©e : 7 √† 25 ans', 'Taux : 2.8% √† 4.1%'],
                'advantages': ['Taux avantageux', 'Dur√©e longue possible', 'Assurance obligatoire incluse']
            },
            'automobile': {
                'name': 'Cr√©dit Automobile',
                'description': 'Financez votre v√©hicule en toute simplicit√©',
                'features': ['Montant : 5 000‚Ç¨ √† 100 000‚Ç¨', 'Dur√©e : 12 √† 84 mois', 'Taux : 3.2% √† 5.8%'],
                'advantages': ['Taux comp√©titifs', 'D√©lai de r√©ponse rapide', 'Financement 100% possible']
            },
            'travaux': {
                'name': 'Cr√©dit Travaux',
                'description': 'R√©alisez vos travaux de r√©novation',
                'features': ['Montant : 3 000‚Ç¨ √† 50 000‚Ç¨', 'Dur√©e : 12 √† 60 mois', 'Taux : 5.1% √† 8.3%'],
                'advantages': ['Financement des travaux', 'Devis obligatoire', 'Assurance optionnelle']
            }
        }
        
        print("‚úÖ Chatbot Bancaire initialis√© avec succ√®s !")
    
    def load_models(self, intent_model_path: str = "./intent_model") -> bool:
        """
        Charge les mod√®les entra√Æn√©s avec fallback vers le classificateur simple
        """
        print("üîÑ Chargement des mod√®les...")
        
        # Tentative de chargement du mod√®le d'intent avanc√©
        try:
            intent_loaded = self.intent_classifier.load_trained_model(intent_model_path)
            
            if not intent_loaded:
                print("‚ö†Ô∏è  Mod√®le d'intent non trouv√©. Entra√Ænement en cours...")
                self.intent_classifier.train()
                intent_loaded = True
                
            if intent_loaded:
                print("‚úÖ Mod√®le d'intent avanc√© charg√© !")
                self.use_simple_classifier = False
                
        except Exception as e:
            print(f"‚ö†Ô∏è  Erreur avec le mod√®le avanc√© : {e}")
            print("üîÑ Basculement vers le classificateur simple...")
            self.use_simple_classifier = True
        
        if self.use_simple_classifier:
            print("‚úÖ Classificateur simple activ√© !")
        
        print("‚úÖ Mod√®les charg√©s avec succ√®s !")
        return True
    
    def process_message(self, message: str, user_id: str = "default") -> Dict[str, Any]:
        """
        Traite un message utilisateur et retourne la r√©ponse
        """
        print(f"\nüë§ Utilisateur ({user_id}): {message}")
        
        # Initialisation du contexte utilisateur si n√©cessaire
        if user_id not in self.conversation_context:
            self.conversation_context[user_id] = {
                'last_intent': None,
                'last_entities': {},
                'simulation_history': [],
                'conversation_count': 0
            }
        
        context = self.conversation_context[user_id]
        context['conversation_count'] += 1
        
        # Classification de l'intent avec fallback
        if self.use_simple_classifier:
            # Utilisation du classificateur simple
            simple_result = self.simple_classifier.predict(message)
            intent = simple_result['intent']
            confidence = simple_result['confidence']
            entities = simple_result['entities']
            entity_confidence = confidence  # M√™me confiance pour les entit√©s simples
        else:
            # Tentative avec le mod√®le avanc√©
            try:
                intent_result = self.intent_classifier.predict_intent_with_confidence(message)
                intent = intent_result['intent']
                confidence = intent_result['confidence']
            except Exception as e:
                print(f"‚ùå Erreur lors de la classification d'intent : {e}")
                print("üîÑ Basculement vers le classificateur simple...")
                self.use_simple_classifier = True
                simple_result = self.simple_classifier.predict(message)
                intent = simple_result['intent']
                confidence = simple_result['confidence']
                entities = simple_result['entities']
                entity_confidence = confidence
            
            # Extraction des entit√©s (seulement si mod√®le avanc√© fonctionne)
            if not self.use_simple_classifier:
                try:
                    entity_result = self.entity_extractor.extract_entities_with_validation(message)
                    entities = entity_result['validated_entities']
                    entity_confidence = entity_result['confidence']
                except Exception as e:
                    print(f"‚ùå Erreur lors de l'extraction d'entit√©s : {e}")
                    # Fallback vers l'extraction simple
                    entities = self.simple_classifier.extract_entities(message)
                    entity_confidence = 0.5
        
        # Mise √† jour du contexte
        context['last_intent'] = intent
        context['last_entities'] = entities
        
        # G√©n√©ration de la r√©ponse
        response = self.generate_response(intent, entities, context, confidence, entity_confidence,user_id)
        
        # Sauvegarde de la simulation si applicable
        if intent == 'simulation_credit' and entities:
            self.save_simulation(user_id, entities, response)
        
        result = {
            'intent': intent,
            'confidence': confidence,
            'entities': entities,
            'entity_confidence': entity_confidence,
            'response': response,
            'context': context
        }
        
        print(f"ü§ñ Chatbot: {response}")
        return result
    
    def generate_response(self, intent: str, entities: Dict[str, Any], context: Dict[str, Any], 
                         intent_confidence: float, entity_confidence: float, user_id: str) -> str:
        """
        G√©n√®re une r√©ponse adapt√©e selon l'intent et les entit√©s
        """
        # V√©rification de la confiance (seuil adapt√© selon le classificateur utilis√©)
        confidence_threshold = 0.1 if self.use_simple_classifier else 0.5
        if intent_confidence < confidence_threshold:
            return "Je ne suis pas s√ªr de bien comprendre votre demande. Pouvez-vous reformuler ?"
        
        if intent == 'simulation_credit':
            return self.generate_simulation_response(user_id,entities, context)
        
        elif intent == 'demande_credit':
            return self.generate_credit_request_response(entities, context)
        
        elif intent == 'information_produit':
            return self.generate_product_info_response(entities, context)
        
        elif intent == 'calcul_financier':
            return self.generate_financial_calc_response(entities, context)
        
        elif intent == 'support_client':
            return self.generate_support_response(entities, context)
        
        elif intent == 'modification_simulation':
            return self.generate_modification_response(entities, context)
        
        else:
            return "Je ne comprends pas votre demande. Pouvez-vous reformuler ?"
    
    def generate_simulation_response(self,user_id: str, entities: Dict[str, Any], context: Dict[str, Any]) -> str:
        """
        G√©n√®re une r√©ponse pour une simulation de cr√©dit
        """
        # V√©rification des param√®tres n√©cessaires
        required_params = ['montant', 'duree']
        missing_params = [param for param in required_params if param not in entities]
        
        if missing_params:
            return f"Pour faire votre simulation, il me manque : {', '.join(missing_params)}. Pouvez-vous me les pr√©ciser ?"
        
        # R√©cup√©ration des param√®tres avec conversion
        try:
            montant = int(entities['montant'])
            duree = int(entities['duree'])
        except (ValueError, TypeError):
            return "‚ùå Erreur : montant et dur√©e doivent √™tre des nombres."
        
        credit_type = entities.get('type_credit', 'personnel')
        with_insurance = entities.get('assurance', False)
        
        try:
            # Calcul de la simulation
            simulation = self.credit_calculator.simulate_credit(
                capital=montant,
                duration_years=duree,
                credit_type=credit_type,
                with_insurance=with_insurance
            )
            
            # Formatage de la r√©ponse
            response = self.credit_calculator.format_simulation_result(simulation)
            
            # Ajout d'une proposition d'assurance si pas d√©j√† incluse
            if not with_insurance and credit_type != 'immobilier':
                response += "\n\nSouhaitez-vous ajouter une assurance emprunteur √† cette simulation ?"
            # ‚úÖ Sauvegarde de la simulation dans l'historique
            self.save_simulation(
            user_id,
            {
                'montant': montant,
                'duree': duree,
                'type_credit': credit_type,
                'assurance': with_insurance
            },
            response
            )
        
            return response
            
        except ValueError as e:
            return f"‚ùå Erreur dans les param√®tres : {e}"
        except Exception as e:
            return f"‚ùå Erreur lors du calcul : {e}"
    
    def generate_credit_request_response(self, entities: Dict[str, Any], context: Dict[str, Any]) -> str:
        """
        G√©n√®re une r√©ponse pour une demande de cr√©dit
        """
        response = """üìã **√âtapes de la demande de cr√©dit :**

1Ô∏è‚É£ **V√©rification d'√©ligibilit√©**
   - Revenus minimum : 1500‚Ç¨/mois
   - √Çge : 18-75 ans
   - R√©sidence en France

2Ô∏è‚É£ **Documents n√©cessaires :**
   - Pi√®ce d'identit√©
   - Justificatifs de revenus (3 derniers bulletins)
   - Justificatif de domicile
   - RIB

3Ô∏è‚É£ **Rendez-vous conseiller :**
   Souhaitez-vous prendre rendez-vous avec un conseiller pour finaliser votre demande ?

‚è∞ **Dur√©e de traitement :** 48-72h apr√®s r√©ception du dossier complet

üí° **Conseil :** Avez-vous d√©j√† fait une simulation ? C'est recommand√© avant de faire votre demande."""
        
        return response
    
    def generate_product_info_response(self, entities: Dict[str, Any], context: Dict[str, Any]) -> str:
        """
        G√©n√®re une r√©ponse pour les informations sur les produits
        """
        credit_type = entities.get('type_credit', None)
        
        if credit_type and credit_type in self.product_info:
            product = self.product_info[credit_type]
            
            response = f"""üè¶ **{product['name']}**

üìù **Description :**
{product['description']}

üìä **Caract√©ristiques :**
"""
            for feature in product['features']:
                response += f"‚Ä¢ {feature}\n"
            
            response += "\n‚úÖ **Avantages :**\n"
            for advantage in product['advantages']:
                response += f"‚Ä¢ {advantage}\n"
            
            response += f"\nüí° **Conseil :** Souhaitez-vous une simulation personnalis√©e pour ce type de cr√©dit ?"
            
            return response
        else:
            # Affiche tous les produits si aucun type pr√©cis n'est donn√©
            response = "üè¶ **Tous nos produits de cr√©dit :**\n\n"
            for product in self.product_info.values():
                response += f"**{product['name']}**\n"
                response += f"üìù Description : {product['description']}\n"
                response += "üìä Caract√©ristiques :\n"
                for feature in product['features']:
                    response += f"‚Ä¢ {feature}\n"
                response += "‚úÖ Avantages :\n"
                for advantage in product['advantages']:
                    response += f"‚Ä¢ {advantage}\n"
                response += "\n"
            return response


    
    def generate_financial_calc_response(self, entities: Dict[str, Any], context: Dict[str, Any]) -> str:
        """
        G√©n√®re une r√©ponse pour les calculs financiers
        """
        # V√©rification s'il y a une simulation pr√©c√©dente
        if context.get('simulation_history'):
            last_simulation = context['simulation_history'][-1]
            
            response = """üí∞ **Calculs financiers :**

üìä **D√©tail des co√ªts :**
‚Ä¢ Co√ªt du cr√©dit (hors assurance) : {total_interest:,.0f}‚Ç¨
‚Ä¢ Frais de dossier : {filing_fees}‚Ç¨
‚Ä¢ Co√ªt total : {total_cost:,.0f}‚Ç¨

üìà **Comparaisons possibles :**
‚Ä¢ Avec/sans assurance
‚Ä¢ Diff√©rentes dur√©es
‚Ä¢ Diff√©rents montants

Que souhaitez-vous calculer pr√©cis√©ment ?""".format(
                total_interest=last_simulation.get('total_interest', 0),
                filing_fees=last_simulation.get('filing_fees', 0),
                total_cost=last_simulation.get('total_paid', 0)
            )
            
            return response
        # ‚úÖ Si aucune simulation, mais montant et dur√©e fournis ‚Üí calcul TAEG direct
        elif 'montant' in entities and 'duree' in entities:
         try:
            montant = int(entities['montant'])
            duree = int(entities['duree'])
            taux = self.credit_calculator.taux_annuel
            taeg = self.credit_calculator.calculer_taeg(montant, duree, taux)
            return f"üìà Le TAEG pour un cr√©dit de {montant}‚Ç¨ sur {duree} ans √† {taux}% est de **{taeg}%**."
         except Exception as e:
            return f"‚ùå Erreur lors du calcul du TAEG : {e}"
    
    # ‚ùå Si pas assez d'infos
        else:
         return "Pour calculer le TAEG, pr√©cisez au moins le montant et la dur√©e du cr√©dit."
    def generate_support_response(self, entities: Dict[str, Any], context: Dict[str, Any]) -> str:
        """
        G√©n√®re une r√©ponse pour le support client
        """
        response = """üîß **Support Client**

Je suis l√† pour vous aider ! Voici les options disponibles :

üìû **Contact conseiller :**
‚Ä¢ T√©l√©phone : 01 23 45 67 89
‚Ä¢ Horaires : Lun-Ven 9h-18h, Sam 9h-12h
‚Ä¢ Email : conseiller@banque.fr

üí¨ **Chat en direct :**
‚Ä¢ Disponible 24h/24
‚Ä¢ Temps de r√©ponse : < 2 minutes

üìß **Email support :**
‚Ä¢ support@banque.fr
‚Ä¢ R√©ponse sous 24h

üîê **Mot de passe oubli√© :**
‚Ä¢ Cliquez sur "Mot de passe oubli√©" sur la page de connexion
‚Ä¢ Un lien de r√©initialisation vous sera envoy√© par email

Que puis-je faire pour vous aider davantage ?"""
        
        return response
    
    def generate_modification_response(self, entities: Dict[str, Any], context: Dict[str, Any]) -> str:
        """
        G√©n√®re une r√©ponse pour la modification de simulation
        """
        if not context.get('simulation_history'):
            return "Je n'ai pas de simulation pr√©c√©dente √† modifier. Pouvez-vous d'abord faire une simulation ?"
        
        # R√©cup√©ration de la derni√®re simulation
        last_simulation = context['simulation_history'][-1]
        
        # Cr√©ation d'une nouvelle simulation avec les param√®tres modifi√©s
        new_params = last_simulation.copy()
        new_params.update(entities)
        
        try:
            new_simulation = self.credit_calculator.simulate_credit(
                capital=new_params['montant'],
                duration_years=new_params['duree'],
                credit_type=new_params.get('type_credit', 'personnel'),
                with_insurance=new_params.get('assurance', False)
            )
            
            # Comparaison avec l'ancienne simulation
            comparison = self.credit_calculator.compare_simulations(last_simulation, new_simulation)
            
            return f"‚úÖ **Simulation modifi√©e**\n\n{comparison}"
            
        except Exception as e:
            return f"‚ùå Erreur lors de la modification : {e}"
    
    def save_simulation(self, user_id: str, entities: Dict[str, Any], response: str):
        """
        Sauvegarde une simulation dans l'historique
        """
        try:
            simulation = self.credit_calculator.simulate_credit(
                capital=entities['montant'],
                duration_years=entities['duree'],
                credit_type=entities.get('type_credit', 'personnel'),
                with_insurance=entities.get('assurance', False)
            )
            print(f"üíæ Sauvegarde simulation pour {user_id} | montant={entities['montant']} | dur√©e={entities['duree']}")
            
            self.conversation_context[user_id]['simulation_history'].append(simulation)
            
            # Limitation de l'historique √† 5 simulations
            if len(self.conversation_context[user_id]['simulation_history']) > 5:
                self.conversation_context[user_id]['simulation_history'].pop(0)
                
        except Exception as e:
            print(f"‚ùå Erreur lors de la sauvegarde de la simulation : {e}")
    
    def get_conversation_summary(self, user_id: str) -> Dict[str, Any]:
        """
        Retourne un r√©sum√© de la conversation
        """
        if user_id not in self.conversation_context:
            return {}
        
        context = self.conversation_context[user_id]
        
        return {
            'conversation_count': context['conversation_count'],
            'last_intent': context['last_intent'],
            'simulation_count': len(context['simulation_history']),
            'last_simulation': context['simulation_history'][-1] if context['simulation_history'] else None
        }

# Fonction pour tester le chatbot
def test_chatbot():
    """
    Teste le chatbot avec des exemples
    """
    chatbot = ChatbotBancaire()
    
    # Test de chargement des mod√®les
    if not chatbot.load_models():
        print("‚ùå Impossible de charger les mod√®les")
        return
    
    # Exemples de test
    test_messages = [
        "Bonjour, je voudrais simuler un cr√©dit personnel de 50 000‚Ç¨ sur 5 ans",
        "Qu'est-ce qu'un cr√©dit immobilier ?",
        "Je veux faire une demande de cr√©dit",
        "Calculez-moi le TAEG",
        "Je voudrais changer la dur√©e √† 7 ans",
        "Comment contacter un conseiller ?"
    ]
    
    print("\nüß™ Test du Chatbot Bancaire")
    print("=" * 50)
    
    for i, message in enumerate(test_messages, 1):
        print(f"\n--- Test {i} ---")
        result = chatbot.process_message(message, f"user_{i}")
        
        print(f"üéØ Intent d√©tect√©: {result['intent']} (confiance: {result['confidence']:.3f})")
        if result['entities']:
            print(f"üîç Entit√©s extraites: {result['entities']}")
        
        print(f"üìä R√©sum√© conversation: {chatbot.get_conversation_summary(f'user_{i}')}")
        from credit_calculator import calculer_mensualite
from entity_extractor import extract_entities

def handle_simulation(message):
    entities = extract_entities(message)
    montant = entities["montant"]
    duree = entities["duree"]
    type_credit = entities["type_credit"]

    if not montant or not duree:
        return "Pouvez-vous pr√©ciser le montant et la dur√©e du cr√©dit ?"

    mensualite = calculer_mensualite(float(montant), duree, taux_annuel=0.02)
    return f"Pour un cr√©dit {type_credit} de {montant}‚Ç¨ sur {duree} ans, la mensualit√© estim√©e est de {mensualite:.2f}‚Ç¨/mois."


if __name__ == "__main__":
    # Test du chatbot
    test_chatbot() 